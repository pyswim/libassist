<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS测距仪 - 带轨迹绘制</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c2461, #1e3799);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #78ffd6, #a8ff78);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }
        
        .distance-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .distance-value {
            font-size: 4.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #78ffd6;
            text-shadow: 0 0 15px rgba(120, 255, 214, 0.5);
        }
        
        .distance-unit {
            font-size: 1.5rem;
            color: #aaa;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }
        
        button {
            padding: 18px 25px;
            font-size: 1.1rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        #startBtn {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }
        
        #startBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 176, 155, 0.4);
        }
        
        #stopBtn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            color: white;
        }
        
        #stopBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(255, 65, 108, 0.4);
        }
        
        #resetBtn {
            background: linear-gradient(to right, #8e9eab, #eef2f3);
            color: #333;
        }
        
        #resetBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(142, 158, 171, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .tracking-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            grid-row: span 2;
            display: flex;
            flex-direction: column;
        }
        
        .tracking-panel h2 {
            color: #78ffd6;
            margin-bottom: 20px;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .map-container {
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        
        #trackCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .no-track-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-size: 1.2rem;
        }
        
        .stats-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stats-panel h2 {
            color: #a8ff78;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .stat-item {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: #fff;
        }
        
        .path-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .path-panel h2 {
            color: #a8ff78;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .path-list-container {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #pathList {
            list-style-type: none;
        }
        
        #pathList li {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #pathList li:last-child {
            border-bottom: none;
        }
        
        .point-time {
            font-size: 0.9rem;
            color: #aaa;
        }
        
        .point-coords {
            font-family: monospace;
            font-size: 0.9rem;
            color: #78ffd6;
        }
        
        .footer {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            color: #aaa;
            font-size: 0.9rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-top: 10px;
        }
        
        /* 动画效果 */
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .recording {
            animation: pulse 1.5s infinite;
        }
        
        .coordinates {
            font-family: monospace;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .canvas-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .canvas-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .canvas-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 15px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .distance-value {
                font-size: 3.5rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            button {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>GPS测距仪 - 轨迹绘制版</h1>
            <p class="subtitle">记录您的运动路径，实时显示距离并动态绘制轨迹</p>
        </header>
        
        <div class="distance-panel">
            <div class="distance-value" id="distance">0.00</div>
            <div class="distance-unit">米</div>
            
            <div class="controls">
                <button id="startBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polygon points="10 8 16 12 10 16 10 8"></polygon>
                    </svg>
                    开始记录
                </button>
                <button id="stopBtn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="6" width="12" height="12"></rect>
                    </svg>
                    停止记录
                </button>
                <button id="resetBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                    重置
                </button>
            </div>
        </div>
        
        <div class="tracking-panel">
            <h2>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                运动轨迹
            </h2>
            <div class="map-container">
                <canvas id="trackCanvas"></canvas>
                <div class="no-track-message" id="noTrackMessage">
                    等待开始记录<br>
                    <span style="font-size: 0.9rem;">运动轨迹将在这里实时绘制</span>
                </div>
            </div>
            <div class="canvas-controls">
                <button class="canvas-btn" id="zoomInBtn">放大轨迹</button>
                <button class="canvas-btn" id="zoomOutBtn">缩小轨迹</button>
                <button class="canvas-btn" id="centerBtn">居中显示</button>
                <button class="canvas-btn" id="clearTrackBtn">清除轨迹</button>
            </div>
        </div>
        
        <div class="stats-panel">
            <h2>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="20" x2="18" y2="10"></line>
                    <line x1="12" y1="20" x2="12" y2="4"></line>
                    <line x1="6" y1="20" x2="6" y2="14"></line>
                </svg>
                统计信息
            </h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">状态</div>
                    <div class="stat-value" id="status">等待开始</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">路径点数</div>
                    <div class="stat-value" id="pointCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">定位精度</div>
                    <div class="stat-value" id="accuracy">-- 米</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">平均速度</div>
                    <div class="stat-value" id="avgSpeed">-- 米/秒</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">记录时长</div>
                    <div class="stat-value" id="duration">00:00</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">最后更新</div>
                    <div class="stat-value" id="lastUpdate">--</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">最大速度</div>
                    <div class="stat-value" id="maxSpeed">-- 米/秒</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">海拔高度</div>
                    <div class="stat-value" id="altitude">-- 米</div>
                </div>
            </div>
        </div>
        
        <div class="path-panel">
            <h2>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                </svg>
                路径记录
            </h2>
            <div class="path-list-container">
                <ul id="pathList">
                    <li>暂无数据，点击"开始记录"按钮开始测量</li>
                </ul>
            </div>
        </div>
        
        <div class="footer">
            <p>GPS测距仪 - 轨迹绘制版 &copy; 2023 | 使用浏览器Geolocation API | 可在户外使用获得最佳精度</p>
        </div>
    </div>

    <script>
        // 应用状态变量
        let isRecording = false;
        let watchId = null;
        let totalDistance = 0;
        let lastPosition = null;
        let pathPoints = [];
        let startTime = null;
        let timerInterval = null;
        let maxSpeed = 0;
        
        // Canvas绘制相关变量
        let canvas, ctx;
        let canvasWidth, canvasHeight;
        let zoom = 1.0;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        let scale = 50000; // 缩放系数，将GPS坐标转换为像素
        
        // DOM元素
        const distanceElement = document.getElementById('distance');
        const statusElement = document.getElementById('status');
        const pointCountElement = document.getElementById('pointCount');
        const accuracyElement = document.getElementById('accuracy');
        const avgSpeedElement = document.getElementById('avgSpeed');
        const maxSpeedElement = document.getElementById('maxSpeed');
        const durationElement = document.getElementById('duration');
        const lastUpdateElement = document.getElementById('lastUpdate');
        const altitudeElement = document.getElementById('altitude');
        const pathListElement = document.getElementById('pathList');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const noTrackMessage = document.getElementById('noTrackMessage');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const centerBtn = document.getElementById('centerBtn');
        const clearTrackBtn = document.getElementById('clearTrackBtn');
        
        // 初始化Canvas
        function initCanvas() {
            canvas = document.getElementById('trackCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            const container = document.querySelector('.map-container');
            canvasWidth = canvas.width = container.clientWidth;
            canvasHeight = canvas.height = container.clientHeight;
            
            // 添加鼠标事件监听
            canvas.addEventListener('mousedown', startDragging);
            canvas.addEventListener('mousemove', dragCanvas);
            canvas.addEventListener('mouseup', stopDragging);
            canvas.addEventListener('wheel', zoomCanvas);
            
            // 绘制初始状态
            drawTrack();
        }
        
        // 开始记录
        startBtn.addEventListener('click', startRecording);
        
        // 停止记录
        stopBtn.addEventListener('click', stopRecording);
        
        // 重置
        resetBtn.addEventListener('click', resetAll);
        
        // 画布控制按钮
        zoomInBtn.addEventListener('click', () => zoomCanvasManual(1.2));
        zoomOutBtn.addEventListener('click', () => zoomCanvasManual(0.8));
        centerBtn.addEventListener('click', centerTrack);
        clearTrackBtn.addEventListener('click', clearTrack);
        
        // 开始记录函数
        function startRecording() {
            if (isRecording) return;
            
            // 检查浏览器是否支持Geolocation API
            if (!navigator.geolocation) {
                updateStatus("错误：浏览器不支持地理位置功能");
                return;
            }
            
            updateStatus("正在获取位置权限...");
            
            // 请求位置权限
            navigator.geolocation.getCurrentPosition(
                // 成功回调
                (position) => {
                    updateStatus("正在记录路径...");
                    isRecording = true;
                    
                    // 更新按钮状态
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    
                    // 开始计时
                    startTime = new Date();
                    updateTimer();
                    timerInterval = setInterval(updateTimer, 1000);
                    
                    // 开始监听位置变化
                    watchId = navigator.geolocation.watchPosition(
                        handlePositionUpdate,
                        handlePositionError,
                        {
                            enableHighAccuracy: true,
                            maximumAge: 10000,
                            timeout: 5000
                        }
                    );
                    
                    // 添加记录动画效果
                    statusElement.classList.add('recording');
                    
                    // 隐藏"无轨迹"消息
                    noTrackMessage.style.display = 'none';
                    
                    // 记录起始点
                    lastPosition = position;
                    addPathPoint(position, "起始点");
                    
                    // 绘制轨迹
                    drawTrack();
                },
                // 错误回调
                (error) => {
                    handlePositionError(error);
                }
            );
        }
        
        // 停止记录函数
        function stopRecording() {
            if (!isRecording) return;
            
            // 停止位置监听
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // 停止计时器
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            isRecording = false;
            updateStatus("已停止记录");
            
            // 更新按钮状态
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            // 移除动画效果
            statusElement.classList.remove('recording');
            
            // 记录结束点
            if (lastPosition) {
                addPathPoint(lastPosition, "结束点");
            }
            
            // 绘制最终轨迹
            drawTrack();
        }
        
        // 重置所有数据
        function resetAll() {
            stopRecording();
            
            totalDistance = 0;
            lastPosition = null;
            pathPoints = [];
            maxSpeed = 0;
            startTime = null;
            
            // 更新显示
            distanceElement.textContent = "0.00";
            pointCountElement.textContent = "0";
            accuracyElement.textContent = "-- 米";
            avgSpeedElement.textContent = "-- 米/秒";
            maxSpeedElement.textContent = "-- 米/秒";
            durationElement.textContent = "00:00";
            lastUpdateElement.textContent = "--";
            altitudeElement.textContent = "-- 米";
            
            // 清空路径列表
            pathListElement.innerHTML = '<li>暂无数据，点击"开始记录"按钮开始测量</li>';
            
            // 重置画布
            centerTrack();
            noTrackMessage.style.display = 'block';
            
            updateStatus("已重置，等待开始");
        }
        
        // 处理位置更新
        function handlePositionUpdate(position) {
            if (!isRecording) return;
            
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const altitude = position.coords.altitude;
            const speed = position.coords.speed;
            const timestamp = new Date(position.timestamp);
            
            // 更新状态显示
            accuracyElement.textContent = accuracy.toFixed(1) + " 米";
            lastUpdateElement.textContent = timestamp.toLocaleTimeString();
            
            if (altitude !== null) {
                altitudeElement.textContent = altitude.toFixed(1) + " 米";
            }
            
            // 如果是第一个点，只记录不计算距离
            if (!lastPosition) {
                lastPosition = position;
                addPathPoint(position, "起点");
                return;
            }
            
            // 计算与上一个点的距离（使用Haversine公式）
            const distance = calculateDistance(
                lastPosition.coords.latitude,
                lastPosition.coords.longitude,
                latitude,
                longitude
            );
            
            // 计算时间差（秒）
            const timeDiff = (position.timestamp - lastPosition.timestamp) / 1000;
            
            // 如果距离太小，可能是GPS误差，可以忽略
            if (distance > 0.5) {
                totalDistance += distance;
                
                // 更新总距离显示
                distanceElement.textContent = totalDistance.toFixed(2);
                
                // 计算速度
                let currentSpeed = speed;
                if (currentSpeed === null || currentSpeed < 0) {
                    currentSpeed = timeDiff > 0 ? distance / timeDiff : 0;
                }
                
                // 更新最大速度
                if (currentSpeed > maxSpeed) {
                    maxSpeed = currentSpeed;
                    maxSpeedElement.textContent = maxSpeed.toFixed(1) + " 米/秒";
                }
                
                // 计算平均速度
                const elapsedSeconds = (new Date() - startTime) / 1000;
                if (elapsedSeconds > 0) {
                    const avgSpeed = totalDistance / elapsedSeconds;
                    avgSpeedElement.textContent = avgSpeed.toFixed(1) + " 米/秒";
                }
                
                // 记录路径点
                addPathPoint(position, `移动 ${distance.toFixed(1)} 米`);
                
                // 更新上一个点
                lastPosition = position;
                
                // 绘制轨迹
                drawTrack();
            }
        }
        
        // 处理位置错误
        function handlePositionError(error) {
            let errorMessage = "位置获取错误: ";
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage += "用户拒绝了位置访问请求";
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage += "位置信息不可用";
                    break;
                case error.TIMEOUT:
                    errorMessage += "获取位置信息超时";
                    break;
                default:
                    errorMessage += "未知错误";
                    break;
            }
            
            updateStatus(errorMessage);
            
            // 如果正在记录，停止记录
            if (isRecording) {
                stopRecording();
            }
        }
        
        // 更新状态显示
        function updateStatus(message) {
            statusElement.textContent = message;
        }
        
        // 更新计时器显示
        function updateTimer() {
            if (!startTime) return;
            
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000); // 秒
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            durationElement.textContent = 
                (minutes < 10 ? "0" + minutes : minutes) + ":" + 
                (seconds < 10 ? "0" + seconds : seconds);
        }
        
        // 添加路径点到列表
        function addPathPoint(position, description) {
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            const timestamp = new Date(position.timestamp);
            
            // 创建路径点对象
            const point = {
                lat: latitude,
                lng: longitude,
                time: timestamp,
                desc: description,
                speed: position.coords.speed || 0
            };
            
            // 添加到路径点数组
            pathPoints.push(point);
            
            // 更新路径点数量
            pointCountElement.textContent = pathPoints.length;
            
            // 更新路径列表显示
            if (pathPoints.length === 1) {
                // 如果是第一个点，清空默认提示
                pathListElement.innerHTML = '';
            }
            
            const listItem = document.createElement('li');
            const timeString = timestamp.toLocaleTimeString();
            
            listItem.innerHTML = `
                <div>
                    <div style="font-weight: 500;">${description}</div>
                    <div class="point-coords">${latitude.toFixed(6)}, ${longitude.toFixed(6)}</div>
                </div>
                <div class="point-time">${timeString}</div>
            `;
            
            pathListElement.appendChild(listItem);
            
            // 滚动到底部
            pathListElement.parentElement.scrollTop = pathListElement.parentElement.scrollHeight;
        }
        
        // 计算两个经纬度点之间的距离（使用Haversine公式）
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // 地球半径（米）
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c; // 返回距离（米）
        }
        
        // 绘制轨迹函数
        function drawTrack() {
            if (!canvas || !ctx) return;
            
            // 清除画布
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // 绘制网格背景
            drawGrid();
            
            if (pathPoints.length === 0) return;
            
            // 计算轨迹边界
            let minLat = pathPoints[0].lat;
            let maxLat = pathPoints[0].lat;
            let minLng = pathPoints[0].lng;
            let maxLng = pathPoints[0].lng;
            
            for (const point of pathPoints) {
                minLat = Math.min(minLat, point.lat);
                maxLat = Math.max(maxLat, point.lat);
                minLng = Math.min(minLng, point.lng);
                maxLng = Math.max(maxLng, point.lng);
            }
            
            // 计算中心点
            const centerLat = (minLat + maxLat) / 2;
            const centerLng = (minLng + maxLng) / 2;
            
            // 计算缩放比例，使轨迹适应画布
            const latRange = maxLat - minLat;
            const lngRange = maxLng - minLng;
            
            // 防止除零错误
            if (latRange === 0 || lngRange === 0) return;
            
            // 计算缩放比例，考虑画布宽高比
            const canvasAspect = canvasWidth / canvasHeight;
            const trackAspect = lngRange / latRange;
            
            let scaleX, scaleY;
            if (trackAspect > canvasAspect) {
                // 轨迹比画布更宽
                scaleX = canvasWidth / lngRange;
                scaleY = scaleX / trackAspect * canvasAspect;
            } else {
                // 轨迹比画布更高
                scaleY = canvasHeight / latRange;
                scaleX = scaleY * trackAspect / canvasAspect;
            }
            
            // 应用用户缩放
            scaleX *= zoom;
            scaleY *= zoom;
            
            // 转换为画布坐标
            function toCanvasX(lng) {
                return (lng - centerLng) * scaleX * scale + canvasWidth/2 + offsetX;
            }
            
            function toCanvasY(lat) {
                return (centerLat - lat) * scaleY * scale + canvasHeight/2 + offsetY;
            }
            
            // 绘制轨迹线
            if (pathPoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(toCanvasX(pathPoints[0].lng), toCanvasY(pathPoints[0].lat));
                
                for (let i = 1; i < pathPoints.length; i++) {
                    ctx.lineTo(toCanvasX(pathPoints[i].lng), toCanvasY(pathPoints[i].lat));
                }
                
                ctx.strokeStyle = '#78ffd6';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            // 绘制轨迹点
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const x = toCanvasX(point.lng);
                const y = toCanvasY(point.lat);
                
                // 起点和终点用不同颜色
                if (i === 0) {
                    // 起点 - 绿色
                    ctx.fillStyle = '#4CAF50';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制起点标记
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('起点', x, y - 15);
                } else if (i === pathPoints.length - 1 && !isRecording) {
                    // 终点 - 红色
                    ctx.fillStyle = '#FF5252';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制终点标记
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('终点', x, y - 15);
                } else {
                    // 中间点 - 蓝色
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制当前点（如果正在记录）
            if (isRecording && lastPosition) {
                const x = toCanvasX(lastPosition.coords.longitude);
                const y = toCanvasY(lastPosition.coords.latitude);
                
                // 绘制当前点标记
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制脉冲动画
                ctx.strokeStyle = 'rgba(255, 152, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 15 + Math.sin(Date.now() / 300) * 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // 绘制"当前位置"标记
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('当前位置', x, y - 20);
            }
            
            // 绘制比例尺
            drawScale(scaleX, scaleY, centerLng, centerLat);
        }
        
        // 绘制网格背景
        function drawGrid() {
            const gridSize = 50;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 垂直线
            for (let x = 0; x <= canvasWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
            }
            
            // 水平线
            for (let y = 0; y <= canvasHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
            }
        }
        
        // 绘制比例尺
        function drawScale(scaleX, scaleY, centerLng, centerLat) {
            // 计算100米对应的像素长度
            const meters = 100;
            // 100米对应的纬度变化（近似值）
            const latPer100m = meters / 111320;
            // 100米对应的经度变化（近似值，在赤道处）
            const lngPer100m = meters / (111320 * Math.cos(centerLat * Math.PI / 180));
            
            const scaleLengthPx = lngPer100m * scaleX * scale;
            
            if (scaleLengthPx > 50 && scaleLengthPx < 300) {
                const startX = 20;
                const startY = canvasHeight - 30;
                
                // 绘制比例尺线
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX + scaleLengthPx, startY);
                ctx.stroke();
                
                // 绘制比例尺刻度
                ctx.beginPath();
                ctx.moveTo(startX, startY - 10);
                ctx.lineTo(startX, startY + 10);
                ctx.moveTo(startX + scaleLengthPx, startY - 10);
                ctx.lineTo(startX + scaleLengthPx, startY + 10);
                ctx.stroke();
                
                // 绘制比例尺文本
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('100米', startX + scaleLengthPx / 2, startY + 5);
            }
        }
        
        // 画布拖拽功能
        function startDragging(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
        
        function dragCanvas(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            offsetX += deltaX;
            offsetY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            drawTrack();
        }
        
        function stopDragging() {
            isDragging = false;
            canvas.style.cursor = 'default';
        }
        
        // 画布缩放功能
        function zoomCanvas(e) {
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= zoomFactor;
            
            // 限制缩放范围
            zoom = Math.max(0.1, Math.min(10, zoom));
            
            drawTrack();
        }
        
        function zoomCanvasManual(factor) {
            zoom *= factor;
            
            // 限制缩放范围
            zoom = Math.max(0.1, Math.min(10, zoom));
            
            drawTrack();
        }
        
        // 居中显示轨迹
        function centerTrack() {
            offsetX = 0;
            offsetY = 0;
            zoom = 1.0;
            drawTrack();
        }
        
        // 清除轨迹（仅清除轨迹，保留统计数据）
        function clearTrack() {
            pathPoints = [];
            drawTrack();
            pointCountElement.textContent = "0";
            
            // 清空路径列表
            pathListElement.innerHTML = '<li>暂无数据，点击"开始记录"按钮开始测量</li>';
            
            // 显示"无轨迹"消息
            noTrackMessage.style.display = 'block';
        }
        
        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus("准备就绪，点击开始按钮");
            
            // 初始化Canvas
            initCanvas();
            
            // 窗口大小变化时重新调整Canvas
            window.addEventListener('resize', function() {
                const container = document.querySelector('.map-container');
                canvasWidth = canvas.width = container.clientWidth;
                canvasHeight = canvas.height = container.clientHeight;
                drawTrack();
            });
            
            // 尝试获取当前位置（不开始记录）以测试功能
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const accuracy = position.coords.accuracy;
                        accuracyElement.textContent = accuracy.toFixed(1) + " 米";
                    },
                    () => {
                        // 静默失败，不影响用户体验
                    }
                );
            }
        });
    </script>
</body>
</html>