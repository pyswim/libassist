<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS测距仪 - 数据导出功能</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c2461, #1e3799);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1.2fr;
            grid-template-rows: auto auto auto;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
            height: calc(100vh - 40px);
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 8px;
            background: linear-gradient(to right, #78ffd6, #a8ff78);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            color: #aaa;
            font-size: 1.1rem;
        }
        
        .control-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .distance-section {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        .distance-value {
            font-size: 3.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #78ffd6;
            text-shadow: 0 0 15px rgba(120, 255, 214, 0.5);
        }
        
        .distance-unit {
            font-size: 1.3rem;
            color: #aaa;
            margin-bottom: 15px;
        }
        
        .distance-label {
            color: #a8ff78;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-row {
            display: flex;
            gap: 15px;
        }
        
        button {
            padding: 18px 25px;
            font-size: 1.1rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex: 1;
        }
        
        #startBtn {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }
        
        #startBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 176, 155, 0.4);
        }
        
        #stopBtn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            color: white;
        }
        
        #stopBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(255, 65, 108, 0.4);
        }
        
        #resetBtn {
            background: linear-gradient(to right, #8e9eab, #eef2f3);
            color: #333;
        }
        
        #resetBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(142, 158, 171, 0.4);
        }
        
        #exportBtn {
            background: linear-gradient(to right, #8A2BE2, #9370DB);
            color: white;
        }
        
        #exportBtn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(138, 43, 226, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .stats-section {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
        }
        
        .settings-title {
            color: #a8ff78;
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .stat-item {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.4rem;
            color: #fff;
        }
        
        .tracking-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            grid-row: span 2;
            display: flex;
            flex-direction: column;
        }
        
        .tracking-panel h2 {
            color: #78ffd6;
            margin-bottom: 20px;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .map-container {
            flex-grow: 1;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            min-height: 500px;
        }
        
        #trackCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: move;
        }
        
        .no-track-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-size: 1.2rem;
            padding: 20px;
        }
        
        .canvas-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .canvas-btn {
            padding: 10px 18px;
            font-size: 0.9rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .canvas-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .footer {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            color: #aaa;
            font-size: 0.9rem;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-top: 10px;
        }
        
        /* 动画效果 */
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        .recording {
            animation: pulse 1.5s infinite;
        }
        
        .info-badge {
            display: inline-block;
            background-color: rgba(120, 255, 214, 0.2);
            color: #78ffd6;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        
        .path-info-panel {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .path-info-panel h2 {
            color: #a8ff78;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .path-info-content {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .path-info-item {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-family: monospace;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .path-info-item:last-child {
            border-bottom: none;
        }
        
        .settings-section {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            order: 3; /* 将设置部分移到最后 */
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 8px;
            color: #ccc;
        }
        
        .setting-value {
            float: right;
            color: #78ffd6;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #78ffd6;
            cursor: pointer;
        }
        
        .distance-comparison {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }
        
        .distance-type {
            text-align: center;
            flex: 1;
        }
        
        .distance-type-label {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .distance-type-value {
            font-size: 1.2rem;
            color: #fff;
        }
        
        .raw-distance {
            color: #ff5252;
        }
        
        .filtered-distance {
            color: #78ffd6;
        }
        
        .distance-diff {
            color: #ff9800;
        }
        
        .export-section {
            margin-top: 15px;
            text-align: center;
        }
        
        .export-format {
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 10px;
            font-family: monospace;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            text-align: left;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 15px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .distance-value {
                font-size: 3rem;
            }
            
            .control-row {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            button {
                padding: 15px;
            }
            
            .canvas-controls {
                justify-content: center;
            }
            
            .canvas-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>GPS测距仪 - 数据导出功能</h1>
            <p class="subtitle">记录运动路径，实时显示距离，并导出CSV数据</p>
        </header>
        
        <div class="control-panel">
            <div class="distance-section">
                <div class="distance-label">滤波后距离</div>
                <div class="distance-value" id="distance">0.00</div>
                <div class="distance-unit">米</div>
                
                <div class="distance-comparison">
                    <div class="distance-type">
                        <div class="distance-type-label">原始距离</div>
                        <div class="distance-type-value raw-distance" id="rawDistance">0.00</div>
                    </div>
                    <div class="distance-type">
                        <div class="distance-type-label">差值</div>
                        <div class="distance-type-value distance-diff" id="distanceDiff">0.00</div>
                    </div>
                    <div class="distance-type">
                        <div class="distance-type-label">滤波距离</div>
                        <div class="distance-type-value filtered-distance" id="filteredDistance">0.00</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-row">
                    <button id="startBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polygon points="10 8 16 12 10 16 10 8"></polygon>
                        </svg>
                        开始记录
                    </button>
                    <button id="stopBtn" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="6" y="6" width="12" height="12"></rect>
                        </svg>
                        停止记录
                    </button>
                </div>
                <div class="control-row">
                    <button id="resetBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                            <path d="M3 3v5h5"></path>
                        </svg>
                        重置
                    </button>
                    <button id="exportBtn" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        导出CSV
                    </button>
                </div>
            </div>
            
            <div class="tracking-panel">
            <h2>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
                运动轨迹
                <span class="info-badge">原始轨迹 vs 滤波后轨迹</span>
            </h2>
            <div class="map-container">
                <canvas id="trackCanvas"></canvas>
                <div class="no-track-message" id="noTrackMessage">
                    等待开始记录<br>
                    <span style="font-size: 0.9rem;">运动轨迹将在这里实时绘制</span>
                </div>
            </div>
            <div class="canvas-controls">
                <button class="canvas-btn" id="zoomInBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        <line x1="11" y1="8" x2="11" y2="14"></line>
                        <line x1="8" y1="11" x2="14" y2="11"></line>
                    </svg>
                    放大
                </button>
                <button class="canvas-btn" id="zoomOutBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        <line x1="8" y1="11" x2="14" y2="11"></line>
                    </svg>
                    缩小
                </button>
                <button class="canvas-btn" id="centerBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="1"></circle>
                    </svg>
                    居中显示
                </button>
                <button class="canvas-btn" id="autoCenterBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                    </svg>
                    自动居中
                </button>
                <button class="canvas-btn" id="clearTrackBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="3 6 5 6 21 6"></polyline>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        <line x1="10" y1="11" x2="10" y2="17"></line>
                        <line x1="14" y1="11" x2="14" y2="17"></line>
                    </svg>
                    清除轨迹
                </button>
            </div>
            </div>
        


            <div class="stats-section">
                <div class="settings-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="20" x2="18" y2="10"></line>
                        <line x1="12" y1="20" x2="12" y2="4"></line>
                        <line x1="6" y1="20" x2="6" y2="14"></line>
                    </svg>
                    统计信息
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">状态</div>
                        <div class="stat-value" id="status">等待开始</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">原始点数</div>
                        <div class="stat-value" id="rawPointCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">滤波后点数</div>
                        <div class="stat-value" id="filteredPointCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">定位精度</div>
                        <div class="stat-value" id="accuracy">-- 米</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">记录时长</div>
                        <div class="stat-value" id="duration">00:00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">平均速度</div>
                        <div class="stat-value" id="avgSpeed">-- 米/秒</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">最大速度</div>
                        <div class="stat-value" id="maxSpeed">-- 米/秒</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">最后更新</div>
                        <div class="stat-value" id="lastUpdate">--</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <div class="settings-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    滤波设置
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">
                        滤波窗口大小
                        <span class="setting-value" id="windowSizeValue">5</span>
                    </label>
                    <input type="range" id="windowSizeSlider" min="3" max="15" step="2" value="5">
                    <div style="color: #888; font-size: 0.85rem; margin-top: 5px;">
                        窗口越大，轨迹越平滑，但响应越慢
                    </div>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">
                        最小移动距离
                        <span class="setting-value" id="minDistanceValue">2.0</span> 米
                    </label>
                    <input type="range" id="minDistanceSlider" min="0.5" max="10" step="0.5" value="2.0">
                    <div style="color: #888; font-size: 0.85rem; margin-top: 5px;">
                        小于此距离的位置变化将被视为噪声而忽略
                    </div>
                </div>
                
                <div class="setting-item">
                    <label class="setting-label">
                        采样间隔
                        <span class="setting-value" id="samplingValue">2000</span> 毫秒
                    </label>
                    <input type="range" id="samplingSlider" min="500" max="5000" step="500" value="2000">
                    <div style="color: #888; font-size: 0.85rem; margin-top: 5px;">
                        采样间隔越长，数据越稳定，但可能丢失细节
                    </div>
                </div>
                
                <div class="export-section">
                    <div class="export-format">
                        CSV导出格式:<br>
                        1. 编号<br>
                        2. 时间<br>
                        3. 原始经度<br>
                        4. 原始纬度<br>
                        5. 平滑经度<br>
                        6. 平滑纬度<br>
                        7. 累积路程(米)
                    </div>
                </div>
            </div>
        </div>
        
        
        <div class="path-info-panel">
            <h2>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                </svg>
                滤波效果分析
            </h2>
            <div class="path-info-content" id="pathInfoContent">
                <div class="path-info-item">开始记录后，这里将显示滤波前后的坐标对比</div>
                <div class="path-info-item">原始坐标：红色标记</div>
                <div class="path-info-item">滤波后坐标：蓝色标记</div>
                <div class="path-info-item">滤波距离：绿色线条</div>
            </div>
        </div>
        
        <div class="footer">
            <p>GPS测距仪增强版 - 数据导出功能 &copy; 2023 | 滤波算法优化 + CSV数据导出</p>
        </div>
    </div>

    <script>
        // 应用状态变量
        let isRecording = false;
        let watchId = null;
        let timerInterval = null;
        
        // 原始数据
        let rawPoints = [];
        let rawDistance = 0;
        let lastRawPosition = null;
        
        // 滤波后数据
        let filteredPoints = [];
        let filteredDistance = 0;
        let lastFilteredPoint = null;
        
        // 滤波参数
        let windowSize = 5; // 滑动窗口大小
        let minDistance = 2.0; // 最小移动距离（米）
        let samplingInterval = 2000; // 采样间隔（毫秒）
        let lastSamplingTime = 0;
        
        // 统计信息
        let startTime = null;
        let maxSpeed = 0;
        let autoCenterEnabled = true;
        
        // 用于累积路程计算
        let cumulativeDistances = [];
        
        // Canvas绘制相关变量
        let canvas, ctx;
        let canvasWidth, canvasHeight;
        let zoom = 1.0;
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;
        
        // DOM元素
        const distanceElement = document.getElementById('distance');
        const rawDistanceElement = document.getElementById('rawDistance');
        const filteredDistanceElement = document.getElementById('filteredDistance');
        const distanceDiffElement = document.getElementById('distanceDiff');
        const statusElement = document.getElementById('status');
        const rawPointCountElement = document.getElementById('rawPointCount');
        const filteredPointCountElement = document.getElementById('filteredPointCount');
        const accuracyElement = document.getElementById('accuracy');
        const avgSpeedElement = document.getElementById('avgSpeed');
        const maxSpeedElement = document.getElementById('maxSpeed');
        const durationElement = document.getElementById('duration');
        const lastUpdateElement = document.getElementById('lastUpdate');
        const pathInfoContent = document.getElementById('pathInfoContent');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const exportBtn = document.getElementById('exportBtn');
        const noTrackMessage = document.getElementById('noTrackMessage');
        
        // 设置控件
        const windowSizeSlider = document.getElementById('windowSizeSlider');
        const windowSizeValue = document.getElementById('windowSizeValue');
        const minDistanceSlider = document.getElementById('minDistanceSlider');
        const minDistanceValue = document.getElementById('minDistanceValue');
        const samplingSlider = document.getElementById('samplingSlider');
        const samplingValue = document.getElementById('samplingValue');
        
        // 画布控制按钮
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const centerBtn = document.getElementById('centerBtn');
        const autoCenterBtn = document.getElementById('autoCenterBtn');
        const clearTrackBtn = document.getElementById('clearTrackBtn');
        
        // 初始化Canvas
        function initCanvas() {
            canvas = document.getElementById('trackCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            const container = document.querySelector('.map-container');
            canvasWidth = canvas.width = container.clientWidth;
            canvasHeight = canvas.height = container.clientHeight;
            
            // 添加鼠标事件监听
            canvas.addEventListener('mousedown', startDragging);
            canvas.addEventListener('mousemove', dragCanvas);
            canvas.addEventListener('mouseup', stopDragging);
            canvas.addEventListener('wheel', zoomCanvas);
            
            // 绘制初始状态
            drawTrack();
        }
        
        // 更新设置控件
        windowSizeSlider.addEventListener('input', function() {
            windowSize = parseInt(this.value);
            windowSizeValue.textContent = windowSize;
            // 重新计算滤波
            recalculateFilteredPath();
        });
        
        minDistanceSlider.addEventListener('input', function() {
            minDistance = parseFloat(this.value);
            minDistanceValue.textContent = minDistance.toFixed(1);
            // 重新计算滤波
            recalculateFilteredPath();
        });
        
        samplingSlider.addEventListener('input', function() {
            samplingInterval = parseInt(this.value);
            samplingValue.textContent = samplingInterval;
        });
        
        // 开始记录
        startBtn.addEventListener('click', startRecording);
        
        // 停止记录
        stopBtn.addEventListener('click', stopRecording);
        
        // 重置
        resetBtn.addEventListener('click', resetAll);
        
        // 导出CSV
        exportBtn.addEventListener('click', exportToCSV);
        
        // 画布控制按钮
        zoomInBtn.addEventListener('click', () => zoomCanvasManual(1.2));
        zoomOutBtn.addEventListener('click', () => zoomCanvasManual(0.8));
        centerBtn.addEventListener('click', centerTrack);
        autoCenterBtn.addEventListener('click', toggleAutoCenter);
        clearTrackBtn.addEventListener('click', clearTrack);
        
        // 开始记录函数
        function startRecording() {
            if (isRecording) return;
            
            // 检查浏览器是否支持Geolocation API
            if (!navigator.geolocation) {
                updateStatus("错误：浏览器不支持地理位置功能");
                return;
            }
            
            updateStatus("正在获取位置权限...");
            
            // 请求位置权限
            navigator.geolocation.getCurrentPosition(
                // 成功回调
                (position) => {
                    updateStatus("正在记录路径...");
                    isRecording = true;
                    
                    // 更新按钮状态
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    exportBtn.disabled = true; // 有数据才能导出
                    
                    // 开始计时
                    startTime = new Date();
                    updateTimer();
                    timerInterval = setInterval(updateTimer, 1000);
                    
                    // 重置采样时间
                    lastSamplingTime = Date.now();
                    
                    // 开始监听位置变化
                    watchId = navigator.geolocation.watchPosition(
                        handlePositionUpdate,
                        handlePositionError,
                        {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 5000
                        }
                    );
                    
                    // 添加记录动画效果
                    statusElement.classList.add('recording');
                    
                    // 隐藏"无轨迹"消息
                    noTrackMessage.style.display = 'none';
                    
                    // 记录起始点
                    addRawPoint(position);
                    
                    // 初始滤波点就是原始点
                    addFilteredPointFromRaw(position);
                    
                    // 绘制轨迹
                    drawTrack();
                },
                // 错误回调
                (error) => {
                    handlePositionError(error);
                }
            );
        }
        
        // 停止记录函数
        function stopRecording() {
            if (!isRecording) return;
            
            // 停止位置监听
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // 停止计时器
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            isRecording = false;
            updateStatus("已停止记录");
            
            // 更新按钮状态
            startBtn.disabled = false;
            stopBtn.disabled = true;
            exportBtn.disabled = false; // 停止记录后可以导出
            
            // 移除动画效果
            statusElement.classList.remove('recording');
            
            // 记录结束点
            if (lastRawPosition) {
                addRawPoint(lastRawPosition);
            }
            
            // 绘制最终轨迹
            drawTrack();
        }
        
        // 重置所有数据
        function resetAll() {
            stopRecording();
            
            rawPoints = [];
            filteredPoints = [];
            rawDistance = 0;
            filteredDistance = 0;
            lastRawPosition = null;
            lastFilteredPoint = null;
            maxSpeed = 0;
            startTime = null;
            lastSamplingTime = 0;
            cumulativeDistances = [];
            
            // 更新显示
            distanceElement.textContent = "0.00";
            rawDistanceElement.textContent = "0.00";
            filteredDistanceElement.textContent = "0.00";
            distanceDiffElement.textContent = "0.00";
            rawPointCountElement.textContent = "0";
            filteredPointCountElement.textContent = "0";
            accuracyElement.textContent = "-- 米";
            avgSpeedElement.textContent = "-- 米/秒";
            maxSpeedElement.textContent = "-- 米/秒";
            durationElement.textContent = "00:00";
            lastUpdateElement.textContent = "--";
            
            // 清空路径信息
            pathInfoContent.innerHTML = `
                <div class="path-info-item">开始记录后，这里将显示滤波前后的坐标对比</div>
                <div class="path-info-item">原始坐标：红色标记</div>
                <div class="path-info-item">滤波后坐标：蓝色标记</div>
                <div class="path-info-item">滤波距离：绿色线条</div>
            `;
            
            // 重置画布
            centerTrack();
            noTrackMessage.style.display = 'block';
            
            // 更新按钮状态
            exportBtn.disabled = true;
            
            updateStatus("已重置，等待开始");
        }
        
        // 处理位置更新
        function handlePositionUpdate(position) {
            if (!isRecording) return;
            
            const currentTime = Date.now();
            
            // 检查采样间隔
            if (currentTime - lastSamplingTime < samplingInterval) {
                return; // 跳过本次采样
            }
            
            lastSamplingTime = currentTime;
            
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            const accuracy = position.coords.accuracy;
            const speed = position.coords.speed;
            const timestamp = new Date(position.timestamp);
            
            // 更新状态显示
            accuracyElement.textContent = accuracy.toFixed(1) + " 米";
            lastUpdateElement.textContent = timestamp.toLocaleTimeString();
            
            // 记录原始点
            addRawPoint(position);
            
            // 应用滤波算法
            applyFilterAndCalculate(position, speed);
            
            // 更新速度统计
            updateSpeedStats(speed);
            
            // 绘制轨迹
            drawTrack();
        }
        
        // 添加原始点
        function addRawPoint(position) {
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            const timestamp = new Date(position.timestamp);
            const accuracy = position.coords.accuracy;
            
            // 创建路径点对象
            const point = {
                lat: latitude,
                lng: longitude,
                time: timestamp,
                accuracy: accuracy,
                speed: position.coords.speed || 0
            };
            
            // 添加到原始点数组
            rawPoints.push(point);
            
            // 如果是第一个点，只记录不计算距离
            if (!lastRawPosition) {
                lastRawPosition = point;
            } else {
                // 计算与上一个点的距离
                const distance = calculateDistance(
                    lastRawPosition.lat,
                    lastRawPosition.lng,
                    latitude,
                    longitude
                );
                
                // 累加原始距离
                rawDistance += distance;
                rawDistanceElement.textContent = rawDistance.toFixed(2);
                
                // 更新上一个点
                lastRawPosition = point;
            }
            
            // 更新原始点数量
            rawPointCountElement.textContent = rawPoints.length;
        }
        
        // 从原始点添加滤波点（用于初始点）
        function addFilteredPointFromRaw(position) {
            const point = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                time: new Date(position.timestamp),
                speed: position.coords.speed || 0
            };
            
            filteredPoints.push(point);
            lastFilteredPoint = point;
            cumulativeDistances.push(0); // 第一个点的累积路程为0
            filteredPointCountElement.textContent = filteredPoints.length;
        }
        
        // 应用滤波算法并计算距离
        function applyFilterAndCalculate(position, speed) {
            // 获取最近windowSize个点进行滑动平均
            const recentPoints = rawPoints.slice(-windowSize);
            
            // 计算平均值
            let sumLat = 0;
            let sumLng = 0;
            
            for (const point of recentPoints) {
                sumLat += point.lat;
                sumLng += point.lng;
            }
            
            const avgLat = sumLat / recentPoints.length;
            const avgLng = sumLng / recentPoints.length;
            
            // 创建滤波后的点
            const filteredPoint = {
                lat: avgLat,
                lng: avgLng,
                time: new Date(),
                speed: speed || 0
            };
            
            // 添加滤波点并计算距离
            addFilteredPoint(filteredPoint);
        }
        
        // 添加滤波点并计算距离
        function addFilteredPoint(filteredPoint) {
            // 添加到滤波点数组
            filteredPoints.push(filteredPoint);
            
            // 如果是第一个点，只记录不计算距离
            if (!lastFilteredPoint) {
                lastFilteredPoint = filteredPoint;
                cumulativeDistances.push(0);
            } else {
                // 计算与上一个滤波点的距离
                const distance = calculateDistance(
                    lastFilteredPoint.lat,
                    lastFilteredPoint.lng,
                    filteredPoint.lat,
                    filteredPoint.lng
                );
                
                // 应用最小距离过滤
                if (distance >= minDistance) {
                    // 累加滤波距离
                    filteredDistance += distance;
                    filteredDistanceElement.textContent = filteredDistance.toFixed(2);
                    
                    // 更新距离差值
                    const diff = Math.abs(filteredDistance - rawDistance);
                    distanceDiffElement.textContent = diff.toFixed(2);
                    
                    // 更新距离显示（主显示为滤波后距离）
                    distanceElement.textContent = filteredDistance.toFixed(2);
                    
                    // 更新上一个点
                    lastFilteredPoint = filteredPoint;
                    
                    // 添加滤波信息到路径信息
                    addFilterInfoToDisplay(filteredPoint, distance);
                } else {
                    // 距离太小，不累加距离，但保留点用于轨迹绘制
                    // 注意：这里不更新lastFilteredPoint，所以距离不会累加
                    // 但点仍然会添加到filteredPoints数组用于绘图
                }
                
                // 记录累积路程（无论是否过滤，都记录当前的总距离）
                cumulativeDistances.push(filteredDistance);
            }
            
            // 更新滤波点数量
            filteredPointCountElement.textContent = filteredPoints.length;
        }
        
        // 重新计算滤波路径（当参数改变时）
        function recalculateFilteredPath() {
            if (rawPoints.length === 0) return;
            
            // 清空滤波点
            filteredPoints = [];
            cumulativeDistances = [];
            filteredDistance = 0;
            lastFilteredPoint = null;
            
            // 对每个原始点重新应用滤波
            for (let i = 0; i < rawPoints.length; i++) {
                // 获取最近windowSize个点（不超过可用点数）
                const startIdx = Math.max(0, i - windowSize + 1);
                const recentPoints = rawPoints.slice(startIdx, i + 1);
                
                // 计算平均值
                let sumLat = 0;
                let sumLng = 0;
                
                for (const point of recentPoints) {
                    sumLat += point.lat;
                    sumLng += point.lng;
                }
                
                const avgLat = sumLat / recentPoints.length;
                const avgLng = sumLng / recentPoints.length;
                
                // 创建滤波后的点
                const filteredPoint = {
                    lat: avgLat,
                    lng: avgLng,
                    time: rawPoints[i].time,
                    speed: rawPoints[i].speed || 0
                };
                
                // 添加滤波点并计算距离
                if (!lastFilteredPoint) {
                    // 第一个点
                    filteredPoints.push(filteredPoint);
                    lastFilteredPoint = filteredPoint;
                    cumulativeDistances.push(0);
                } else {
                    // 计算距离
                    const distance = calculateDistance(
                        lastFilteredPoint.lat,
                        lastFilteredPoint.lng,
                        filteredPoint.lat,
                        filteredPoint.lng
                    );
                    
                    // 应用最小距离过滤
                    if (distance >= minDistance) {
                        // 累加距离
                        filteredDistance += distance;
                        // 更新上一个点
                        lastFilteredPoint = filteredPoint;
                    }
                    
                    // 无论是否累加距离，都添加点到数组用于绘图
                    filteredPoints.push(filteredPoint);
                    cumulativeDistances.push(filteredDistance);
                }
            }
            
            // 更新显示
            filteredDistanceElement.textContent = filteredDistance.toFixed(2);
            distanceElement.textContent = filteredDistance.toFixed(2);
            const diff = Math.abs(filteredDistance - rawDistance);
            distanceDiffElement.textContent = diff.toFixed(2);
            filteredPointCountElement.textContent = filteredPoints.length;
            
            // 重新绘制轨迹
            drawTrack();
        }
        
        // 添加滤波信息到显示
        function addFilterInfoToDisplay(filteredPoint, distance) {
            const infoItem = document.createElement('div');
            infoItem.className = 'path-info-item';
            
            infoItem.innerHTML = `
                滤波点: ${filteredPoint.lat.toFixed(6)}, ${filteredPoint.lng.toFixed(6)}<br>
                增量: ${distance.toFixed(2)} 米 | 累计: ${filteredDistance.toFixed(2)} 米
            `;
            
            pathInfoContent.appendChild(infoItem);
            
            // 限制显示数量，最多显示20条
            if (pathInfoContent.children.length > 20) {
                pathInfoContent.removeChild(pathInfoContent.children[0]);
            }
            
            // 滚动到底部
            pathInfoContent.scrollTop = pathInfoContent.scrollHeight;
        }
        
        // 更新速度统计
        function updateSpeedStats(speed) {
            if (speed !== null && speed > 0) {
                // 更新最大速度
                if (speed > maxSpeed) {
                    maxSpeed = speed;
                    maxSpeedElement.textContent = maxSpeed.toFixed(1) + " 米/秒";
                }
                
                // 计算平均速度
                if (startTime) {
                    const elapsedSeconds = (new Date() - startTime) / 1000;
                    if (elapsedSeconds > 0) {
                        const avgSpeed = filteredDistance / elapsedSeconds;
                        avgSpeedElement.textContent = avgSpeed.toFixed(1) + " 米/秒";
                    }
                }
            }
        }
        
        // 处理位置错误
        function handlePositionError(error) {
            let errorMessage = "位置获取错误: ";
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    errorMessage += "用户拒绝了位置访问请求";
                    break;
                case error.POSITION_UNAVAILABLE:
                    errorMessage += "位置信息不可用";
                    break;
                case error.TIMEOUT:
                    errorMessage += "获取位置信息超时";
                    break;
                default:
                    errorMessage += "未知错误";
                    break;
            }
            
            updateStatus(errorMessage);
            
            // 如果正在记录，停止记录
            if (isRecording) {
                stopRecording();
            }
        }
        
        // 更新状态显示
        function updateStatus(message) {
            statusElement.textContent = message;
        }
        
        // 更新计时器显示
        function updateTimer() {
            if (!startTime) return;
            
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 1000); // 秒
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            durationElement.textContent = 
                (minutes < 10 ? "0" + minutes : minutes) + ":" + 
                (seconds < 10 ? "0" + seconds : seconds);
        }
        
        // 计算两个经纬度点之间的距离（使用Haversine公式）
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // 地球半径（米）
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c; // 返回距离（米）
        }
        
        // 导出CSV数据
        function exportToCSV() {
            if (rawPoints.length === 0) {
                alert("没有数据可导出！请先记录一些数据。");
                return;
            }
            
            // 准备CSV内容
            let csvContent = "data:text/csv;charset=utf-8,";
            
            // 添加表头
            csvContent += "编号,时间,原始经度,原始纬度,平滑经度,平滑纬度,累积路程(米)\n";
            
            // 确定要导出的数据点数量（取原始点和滤波点中较小的数量）
            const pointCount = Math.min(rawPoints.length, filteredPoints.length);
            
            // 添加数据行
            for (let i = 0; i < pointCount; i++) {
                const rawPoint = rawPoints[i];
                const filteredPoint = filteredPoints[i];
                const cumulativeDistance = cumulativeDistances[i] || 0;
                
                // 格式化时间
                const timeStr = rawPoint.time.toLocaleTimeString('zh-CN', {
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                // 构建行数据
                const row = [
                    i + 1, // 编号
                    timeStr, // 时间
                    rawPoint.lng.toFixed(6), // 原始经度
                    rawPoint.lat.toFixed(6), // 原始纬度
                    filteredPoint.lng.toFixed(6), // 平滑经度
                    filteredPoint.lat.toFixed(6), // 平滑纬度
                    cumulativeDistance.toFixed(2) // 累积路程
                ].join(",");
                
                csvContent += row + "\n";
            }
            
            // 添加汇总信息
            csvContent += "\n\n汇总信息\n";
            csvContent += `原始总距离,${rawDistance.toFixed(2)} 米\n`;
            csvContent += `滤波后总距离,${filteredDistance.toFixed(2)} 米\n`;
            csvContent += `差值,${Math.abs(rawDistance - filteredDistance).toFixed(2)} 米\n`;
            csvContent += `原始点数,${rawPoints.length}\n`;
            csvContent += `滤波后点数,${filteredPoints.length}\n`;
            csvContent += `记录开始时间,${startTime ? startTime.toLocaleString('zh-CN') : 'N/A'}\n`;
            csvContent += `记录结束时间,${new Date().toLocaleString('zh-CN')}\n`;
            csvContent += `最大速度,${maxSpeed.toFixed(2)} 米/秒\n`;
            csvContent += `平均速度,${avgSpeedElement.textContent}\n`;
            csvContent += `定位精度,${accuracyElement.textContent}\n`;
            
            // 创建下载链接
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `gps_track_${new Date().toISOString().slice(0, 10)}_${new Date().getHours()}${new Date().getMinutes()}.csv`);
            
            // 触发下载
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // 显示导出成功消息
            updateStatus("数据已导出为CSV文件");
            
            // 短暂显示消息
            setTimeout(() => {
                if (!isRecording) {
                    updateStatus("已停止记录");
                }
            }, 2000);
        }
        
        // 绘制轨迹函数
        function drawTrack() {
            if (!canvas || !ctx) return;
            
            // 清除画布
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // 绘制网格背景
            drawGrid();
            
            if (rawPoints.length === 0) return;
            
            // 计算所有点的边界（包括原始点和滤波点）
            let allPoints = [];
            if (filteredPoints.length > 0) {
                allPoints = filteredPoints;
            } else {
                allPoints = rawPoints;
            }
            
            let minLat = allPoints[0].lat;
            let maxLat = allPoints[0].lat;
            let minLng = allPoints[0].lng;
            let maxLng = allPoints[0].lng;
            
            for (const point of allPoints) {
                minLat = Math.min(minLat, point.lat);
                maxLat = Math.max(maxLat, point.lat);
                minLng = Math.min(minLng, point.lng);
                maxLng = Math.max(maxLng, point.lng);
            }
            
            // 计算中心点
            const centerLat = (minLat + maxLat) / 2;
            const centerLng = (minLng + maxLng) / 2;
            
            // 计算范围
            const latRange = maxLat - minLat;
            const lngRange = maxLng - minLng;
            
            // 防止除零错误
            if (latRange === 0 && lngRange === 0) {
                // 所有点都相同，添加一个小范围
                maxLat += 0.0001;
                minLat -= 0.0001;
                maxLng += 0.0001;
                minLng -= 0.0001;
            } else if (latRange === 0) {
                maxLat += 0.0001;
                minLat -= 0.0001;
            } else if (lngRange === 0) {
                maxLng += 0.0001;
                minLng -= 0.0001;
            }
            
            // 重新计算范围
            const finalLatRange = maxLat - minLat;
            const finalLngRange = maxLng - minLng;
            
            // 计算缩放比例，使轨迹适应画布（留出边距）
            const padding = 0.2; // 20%的边距
            const canvasAspect = canvasWidth / canvasHeight;
            const trackAspect = finalLngRange / finalLatRange;
            
            let scaleX, scaleY;
            if (trackAspect > canvasAspect) {
                // 轨迹比画布更宽
                scaleX = canvasWidth / finalLngRange * (1 - padding);
                scaleY = scaleX / trackAspect * canvasAspect;
            } else {
                // 轨迹比画布更高
                scaleY = canvasHeight / finalLatRange * (1 - padding);
                scaleX = scaleY * trackAspect / canvasAspect;
            }
            
            // 应用用户缩放
            scaleX *= zoom;
            scaleY *= zoom;
            
            // 如果启用自动居中，调整偏移量
            if (autoCenterEnabled) {
                // 计算中心点在画布上的位置
                const centerX = canvasWidth / 2;
                const centerY = canvasHeight / 2;
                
                // 计算轨迹中心在画布上的位置
                const trackCenterX = (centerLng - minLng) * scaleX;
                const trackCenterY = (centerLat - minLat) * scaleY;
                
                // 计算偏移量，使轨迹中心在画布中心
                offsetX = centerX - trackCenterX;
                offsetY = centerY - trackCenterY;
            }
            
            // 转换为画布坐标
            function toCanvasX(lng) {
                return (lng - minLng) * scaleX + offsetX;
            }
            
            function toCanvasY(lat) {
                return (lat - minLat) * scaleY + offsetY;
            }
            
            // 绘制原始轨迹线（红色虚线）
            if (rawPoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(toCanvasX(rawPoints[0].lng), toCanvasY(rawPoints[0].lat));
                
                for (let i = 1; i < rawPoints.length; i++) {
                    ctx.lineTo(toCanvasX(rawPoints[i].lng), toCanvasY(rawPoints[i].lat));
                }
                
                ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 绘制滤波后轨迹线（绿色实线）
            if (filteredPoints.length > 1) {
                ctx.beginPath();
                ctx.moveTo(toCanvasX(filteredPoints[0].lng), toCanvasY(filteredPoints[0].lat));
                
                for (let i = 1; i < filteredPoints.length; i++) {
                    ctx.lineTo(toCanvasX(filteredPoints[i].lng), toCanvasY(filteredPoints[i].lat));
                }
                
                ctx.strokeStyle = '#78ffd6';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            // 绘制原始轨迹点（红色小点）
            for (let i = 0; i < rawPoints.length; i++) {
                const point = rawPoints[i];
                const x = toCanvasX(point.lng);
                const y = toCanvasY(point.lat);
                
                // 起点和终点用不同颜色
                if (i === 0) {
                    // 起点 - 红色大点
                    ctx.fillStyle = '#FF5252';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else if (i === rawPoints.length - 1 && !isRecording) {
                    // 终点 - 红色大点
                    ctx.fillStyle = '#FF5252';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // 中间点 - 红色小点
                    ctx.fillStyle = 'rgba(255, 50, 50, 0.7)';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制滤波后轨迹点（蓝色点）
            for (let i = 0; i < filteredPoints.length; i++) {
                const point = filteredPoints[i];
                const x = toCanvasX(point.lng);
                const y = toCanvasY(point.lat);
                
                // 起点和终点用不同颜色
                if (i === 0) {
                    // 起点 - 蓝色大点
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制"起点"标记
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('起点', x, y - 15);
                } else if (i === filteredPoints.length - 1 && !isRecording) {
                    // 终点 - 蓝色大点
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制"终点"标记
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('终点', x, y - 15);
                } else {
                    // 中间点 - 蓝色小点
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 绘制当前点（如果正在记录且有点）
            if (isRecording && filteredPoints.length > 0) {
                const lastPoint = filteredPoints[filteredPoints.length - 1];
                const x = toCanvasX(lastPoint.lng);
                const y = toCanvasY(lastPoint.lat);
                
                // 绘制当前点标记
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制脉冲动画
                ctx.strokeStyle = 'rgba(255, 152, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, 15 + Math.sin(Date.now() / 300) * 5, 0, Math.PI * 2);
                ctx.stroke();
                
                // 绘制"当前位置"标记
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('当前位置', x, y - 20);
            }
            
            // 绘制图例
            drawLegend();
            
            // 绘制比例尺
            drawScale(scaleX, scaleY, minLng, minLat);
        }
        
        // 绘制网格背景
        function drawGrid() {
            const gridSize = 50;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 垂直线
            for (let x = 0; x <= canvasWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
            }
            
            // 水平线
            for (let y = 0; y <= canvasHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
            }
        }
        
        // 绘制图例
        function drawLegend() {
            const legendX = 20;
            const legendY = 20;
            const lineHeight = 20;
            
            // 背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(legendX - 10, legendY - 10, 180, 90);
            
            // 图例标题
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('图例', legendX, legendY);
            
            // 原始轨迹
            ctx.fillStyle = 'rgba(255, 50, 50, 0.7)';
            ctx.beginPath();
            ctx.arc(legendX + 10, legendY + lineHeight + 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.fillText('原始轨迹 (虚线)', legendX + 25, legendY + lineHeight + 8);
            
            // 滤波后轨迹
            ctx.fillStyle = '#78ffd6';
            ctx.beginPath();
            ctx.arc(legendX + 10, legendY + lineHeight * 2 + 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.fillText('滤波后轨迹 (实线)', legendX + 25, legendY + lineHeight * 2 + 8);
            
            // 当前位置
            ctx.fillStyle = '#FF9800';
            ctx.beginPath();
            ctx.arc(legendX + 10, legendY + lineHeight * 3 + 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '12px Arial';
            ctx.fillText('当前位置', legendX + 25, legendY + lineHeight * 3 + 8);
        }
        
        // 绘制比例尺
        function drawScale(scaleX, scaleY, minLng, minLat) {
            // 计算100米对应的像素长度
            const meters = 100;
            
            // 100米对应的纬度变化（近似值）
            const latPer100m = meters / 111320;
            // 100米对应的经度变化（近似值，在当前位置处）
            const avgLat = minLat;
            const lngPer100m = meters / (111320 * Math.cos(avgLat * Math.PI / 180));
            
            // 取较小的一个作为参考，确保比例尺可见
            const scaleLengthPx = Math.min(latPer100m * scaleY, lngPer100m * scaleX);
            
            if (scaleLengthPx > 20 && scaleLengthPx < 300) {
                const startX = canvasWidth - 130;
                const startY = canvasHeight - 40;
                
                // 绘制比例尺线
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX + scaleLengthPx, startY);
                ctx.stroke();
                
                // 绘制比例尺刻度
                ctx.beginPath();
                ctx.moveTo(startX, startY - 10);
                ctx.lineTo(startX, startY + 10);
                ctx.moveTo(startX + scaleLengthPx, startY - 10);
                ctx.lineTo(startX + scaleLengthPx, startY + 10);
                ctx.stroke();
                
                // 绘制比例尺文本
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText('100米', startX + scaleLengthPx / 2, startY + 5);
            }
        }
        
        // 画布拖拽功能
        function startDragging(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
            
            // 禁用自动居中
            autoCenterEnabled = false;
            autoCenterBtn.textContent = "启用自动居中";
        }
        
        function dragCanvas(e) {
            if (!isDragging) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            offsetX += deltaX;
            offsetY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            drawTrack();
        }
        
        function stopDragging() {
            isDragging = false;
            canvas.style.cursor = 'default';
        }
        
        // 画布缩放功能
        function zoomCanvas(e) {
            e.preventDefault();
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            zoom *= zoomFactor;
            
            // 限制缩放范围
            zoom = Math.max(0.1, Math.min(10, zoom));
            
            drawTrack();
        }
        
        function zoomCanvasManual(factor) {
            zoom *= factor;
            
            // 限制缩放范围
            zoom = Math.max(0.1, Math.min(10, zoom));
            
            drawTrack();
        }
        
        // 居中显示轨迹
        function centerTrack() {
            offsetX = 0;
            offsetY = 0;
            zoom = 1.0;
            autoCenterEnabled = true;
            autoCenterBtn.textContent = "禁用自动居中";
            drawTrack();
        }
        
        // 切换自动居中
        function toggleAutoCenter() {
            autoCenterEnabled = !autoCenterEnabled;
            autoCenterBtn.textContent = autoCenterEnabled ? "禁用自动居中" : "启用自动居中";
            
            if (autoCenterEnabled) {
                drawTrack();
            }
        }
        
        // 清除轨迹（仅清除轨迹，保留统计数据）
        function clearTrack() {
            rawPoints = [];
            filteredPoints = [];
            rawDistance = 0;
            filteredDistance = 0;
            lastRawPosition = null;
            lastFilteredPoint = null;
            cumulativeDistances = [];
            
            // 更新显示
            distanceElement.textContent = "0.00";
            rawDistanceElement.textContent = "0.00";
            filteredDistanceElement.textContent = "0.00";
            distanceDiffElement.textContent = "0.00";
            rawPointCountElement.textContent = "0";
            filteredPointCountElement.textContent = "0";
            
            // 清空路径信息
            pathInfoContent.innerHTML = `
                <div class="path-info-item">开始记录后，这里将显示滤波前后的坐标对比</div>
                <div class="path-info-item">原始坐标：红色标记</div>
                <div class="path-info-item">滤波后坐标：蓝色标记</div>
                <div class="path-info-item">滤波距离：绿色线条</div>
            `;
            
            // 更新按钮状态
            exportBtn.disabled = true;
            
            // 绘制空轨迹
            drawTrack();
            
            // 显示"无轨迹"消息
            noTrackMessage.style.display = 'block';
        }
        
        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus("准备就绪，点击开始按钮");
            
            // 初始化Canvas
            initCanvas();
            
            // 窗口大小变化时重新调整Canvas
            window.addEventListener('resize', function() {
                const container = document.querySelector('.map-container');
                canvasWidth = canvas.width = container.clientWidth;
                canvasHeight = canvas.height = container.clientHeight;
                drawTrack();
            });
            
            // 尝试获取当前位置（不开始记录）以测试功能
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const accuracy = position.coords.accuracy;
                        accuracyElement.textContent = accuracy.toFixed(1) + " 米";
                    },
                    () => {
                        // 静默失败，不影响用户体验
                    }
                );
            }
        });
    </script>
</body>
</html>
